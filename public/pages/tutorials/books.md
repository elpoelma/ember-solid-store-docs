# Tutorial: building a small books application
## Prerequisites
* You should have basic working knowledge of Javascript, HTML and Ember.js
* You should have created a new ember application called solid-books with ember-solid-store installed by following our installation guide.
* In order to follow this tutorial, you should create your own Solid pod! In order to create a pod, you can choose between different providers such as: https://solidcommunity.net/, https://signup.pod.inrupt.com/ or you can even host your own server!

## Creating the basic application structure

Our books application will consist of four different routes:
* An authors page which will allow you to list the authors in your solid pod; add new authors or remove existing authors.
* A books page which allows you to manage the books in your pod.
* And a solid authentication page which the add-on has already generated for us.

Generate the two remaining routes using the Ember route-generator:
* ```ember g route authors```
* ```ember g route books```

The books and authors routes will also require accompanying controllers in order to implement adding and removing books and authors. These controllers can be generated by executing:
* ```ember g controller authors```
* ```ember g controller books```

Replace the contents of the application, authors and books templates by the following:

#### **`templates/application.hbs`**
```handlebars
{{page-title "Solid Books"}}


<h1>My Solid book manager</h1>

<LinkTo @route="authors">Authors</LinkTo>
<LinkTo @route="books">Books</LinkTo>
{{outlet}}
```

#### **`templates/authors.hbs`**
```handlebars
{{page-title "Authors"}}

<h2>Authors</h2>
```

#### **`templates/books.hbs`**
```handlebars
{{page-title "Books"}}

<h2>Books</h2>
```

You should now be able to navigate between the authors and books pages.

## Adding Solid authentication

Before fetching the books and authors from your Solid pod, you should first be able to login. In ember-solid-store, authentication is handled by the login route and the solidAuth service. In both the books and authors routes, we want the user to be redirected to a login route when they are not yet autehticated. In order to implement this, we will add the following to the ```beforeModel``` hook of the books and authors routes:

#### **`routes/authors.js`**
```javascript
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AuthorsRoute extends Route {
  @service solidAuth;

  async beforeModel(){
    await this.solidAuth.ensureLogin();
  }
}

```

#### **`routes/books.js`**
```javascript
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class BooksRoute extends Route {
  @service solidAuth;

  async beforeModel(){
    await this.solidAuth.ensureLogin();
  }
}

```

When visiting either the books or authors page, you will now be presented with a login page when you are not yet authenticated. The login page allows you to select between different providers or provide your own.



## Adding authors to our application
We might have an authors page, but it still seems a bit empty. In this section, we will add an overview of the authors in our pod to our application. Additionally, we will implement functionality which allows us to add and remove authors.

In order to represent an author we will add a Semantic model to our app. A new model can be generated using the blueprint ```ember generate model <model_name>```.
Generate an author model by executing ```ember generate model author``` and add the following contents to the Author class:

#### **`models/author.js`**
```javascript
import SemanticModel, {
  solid,
  string,
} from 'ember-solid-store/models/semantic-model';

@solid({
  defaultStorageLocation: '/private/tests/my-authors.ttl',
  private: true,
  type: 'http://schema.org/Person',
  ns: 'http://schema.org/',
})
export default class Author extends SemanticModel {
  @string({
      predicate: "schema:givenName"
  })
  givenName;

  @string({
      predicate: "schema:familyName"
  })
  familyName;

}

```

In this solid-decorator, we define the location of the resource, the access rights, the resource type and the default namespace used in the file. Additionally, we add two properties to the author model: a schema:givenName and a schema:familyName.

We can use this ember-solid-store model in order to retrieve a list of authors in the model-hook of our authors route. Add the following model hook:

#### **`routes/authors.js`**
```javascript
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AuthorsRoute extends Route {
  @service solidAuth;
  @service store;

  async beforeModel(){
    await this.solidAuth.ensureLogin();
  }

  async model() {
    await this.store.fetchGraphForType('author');
    return this.store.all('author');
  }
}

```

```fetchGraphForType('author')``` will retrieve the associated graph to the author model from a Solid pod and ```all('author')``` will return a list of authors loaded into model objects.

In order to render a list of authors, we still need to use the model-hook in the author handlebars-template. Add the following to the authors-template:

#### **`templates/authors.hbs`**
```handlebars
{{page-title "Authors"}}

<h2>Authors</h2>
<ul>
{{#each @model as |author|}}
<li>{{author.givenName}} {{author.familyName}}</li>
{{/each}}
</ul>
```

When opening up the authors route, you will probably notice that no authors are rendered. This because we might not have any authors stored in ```my-authors.ttl``` in our Solid pod! In our to resolve this, we can add an author creation form to our page. We can implement the form in the form of a component, execute: ```ember generate component author-form --with-component-class``` and add the following contents to the resulting javascript and handlebars files:

#### **`components/author-form.hbs`**
```handlebars
<form {{on "submit" this.onCreateAuthor}}>
    <label for="givenName">Given Name</label>
    <Input id="givenName" 
           @type="text"
           @value={{this.givenName}}/>
    <label for="familyName">Family Name</label> 
    <Input id="familyName"
            @type="text"
            @value={{this.familyName}}/>
    <button type="submit">Create Author</button>
</form>
```

#### **`components/author-form.js`**
```javascript
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

export default class AuthorFormComponent extends Component {
  @tracked
  givenName;

  @tracked
  familyName;

  @action
  onCreateAuthor(event) {
    event.preventDefault();
    this.args.onSubmit(this.givenName, this.familyName);
    this.givenName = '';
    this.familyName = '';
  }
}
```
In order to handle off the actual creation of an author, we can provide an ```onSubmit``` property to the form-component. Add the following javascript code to the authors controller:

#### **`controllers/authors.js`**

```javascript
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class AuthorsController extends Controller {
  @service router;
  @service store;

  @action
  async createAuthor(givenName, familyName) {
    this.store.create('author', {
      givenName: givenName,
      familyName: familyName,
    });

    await this.store.persist();

    this.router.refresh();
  }

  @action
  async deleteAuthor(author) {
    author.destroy();
    await this.store.persist();

    this.router.refresh();
  }
}

```

Using ```this.store.create``` we add a new author object our local data-store. ```this.store.persist``` synchronizes the local changes with the remote Solid pod. Besides author creation, we also add a controller action in order to delete a specific author. Add the new form-component and delete-button alongside the ```createAuthor``` and ```deleteAuthor``` methods to the authors route template:

#### **`templates/authors.hbs`**
```handlebars
{{page-title "Authors"}}

<h2>Authors</h2>
<ul>
{{#each @model as |author|}}
<li>{{author.givenName}} {{author.familyName}} <button type="button" {{on "click" (fn this.deleteAuthor author)}}>Delete</button></li>
{{/each}}
</ul>
<AuthorForm @onSubmit={{this.createAuthor}}/>
```

You should now be able to add and remove authors from your collection! In the next section we will go over the books route.



## Authors need some books right?
The books route is implemented in a very similar way to the authors route. Generate and implement the following files in your application:

#### **`models/book.js`**
```javascript
import SemanticModel, {
  solid,
  string,
  integer,
} from 'ember-solid-store/models/semantic-model';

@solid({
  defaultStorageLocation: '/private/tests/my-books.ttl', // default location in solid pod
  private: true, // is this private info for the user?
  type: 'http://schema.org/Book', // optional, defining NS is good enough if this is derived from the namespace.
  ns: 'http://schema.org/', // define a namespace for properties.  http://schema.org/ is a good starting point for finding definitions.  No clue? use 'ext'.
})
export default class Book extends SemanticModel {
  @string({
      predicate: "schema:headLine"
  })
  headLine;

  @integer({
      predicate: "schema:numberOfPages"
  })
  numberOfPages;
}

```

#### **`routes/books.js`**
```javascript
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class BooksRoute extends Route {
  @service solidAuth;
  @service store;

  async beforeModel(){
    await this.solidAuth.ensureLogin();
  }

  async model() {
    await this.store.fetchGraphForType('book');
    return this.store.all('book');
  }
}

```

#### **`templates/books.hbs`**
```handlebars
{{page-title "Books"}}
<h2>Books</h2>
<ul>
{{#each @model as |book|}}
<li>{{book.headLine}} {{book.numberOfPages}} <button type="button" {{on "click" (fn this.deleteBook book)}}>Delete</button></li>
{{/each}}
</ul>
<BookForm @onSubmit={{this.createBook}}/>
```

#### **`controllers/books.js`**

```javascript
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class BooksController extends Controller {
  @service router;
  @service store;

  @action
  async createBook(headLine, numberOfPages) {

    this.store.create('book', {
      headLine: headLine,
      numberOfPages: numberOfPages
    });

    await this.store.persist();

    this.router.refresh();
  }

  @action
  async deleteBook(book) {
    book.destroy();
    await this.store.persist();

    this.router.refresh();
  }
}

```

#### **`components/book-form.hbs`**
```handlebars
<form {{on "submit" this.onCreateBook}}>
    <label for="title">Title</label>
    <Input id="title" 
           @type="text"
           @value={{this.headLine}}/>
    <label for="numberOfPages">Page Count</label> 
    <Input id="numberOfPages"
            @type="text"
            @value={{this.numberOfPages}}/>
    <button type="submit">Create Book</button>
</form>
```

#### **`components/book-form.js`**
```javascript
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class BookFormComponent extends Component {
  @tracked
  headLine;

  @tracked
  numberOfPages;

  @action
  onCreateBook(event) {
    event.preventDefault();
    this.args.onSubmit(this.headLine, this.numberOfPages);
    this.headLine = '';
    this.numberOfPages = '';
  }
}

```

You should now be able to add simple book objects to your collection based on their title and page count. 
Both the book and author routes currently live very seperate lives, in the next section we will go over setting up relations between the author and book models.

## Adding relations between the author and book models
In SemanticModel classes, we can add relations between models using the ```belongsTo``` and ```hasMany``` decorators. Add the following properties to the model files in order to create a many-to-one relation between books and authors.

```javascript
import SemanticModel, {
  solid,
  string,
  integer,
  hasMany,
  belongsTo,
} from 'ember-solid-store/models/semantic-model';

@solid({
  defaultStorageLocation: '/private/tests/my-books.ttl', // default location in solid pod
  private: true, // is this private info for the user?
  type: 'http://schema.org/Book', // optional, defining NS is good enough if this is derived from the namespace.
  ns: 'http://schema.org/', // define a namespace for properties.  http://schema.org/ is a good starting point for finding definitions.  No clue? use 'ext'.
})
export default class Book extends SemanticModel {
  @string()
  headLine;

  @integer()
  numberOfPages;

  @belongsTo({
    model: 'author',
  })
  author;
}

```
In the book model we have added a ```belongsTo``` relation to the author model. As you can see, we also have disposed of the explicit property declarations as embr-solid-store can derive the correct predicates based on the default namespace and the property name.

In the author model, we will add an inverse hasMany relation to the book model:

```javascript
import SemanticModel, {
  solid,
  string,
  hasMany,
} from 'ember-solid-store/models/semantic-model';

@solid({
  defaultStorageLocation: '/private/tests/my-authors.ttl', // default location in solid pod
  private: true, // is this private info for the user?
  type: 'http://schema.org/Person', // optional, defining NS is good enough if this is derived from the namespace.
  ns: 'http://schema.org/', // define a namespace for properties.  http://schema.org/ is a good starting point for finding definitions.  No clue? use 'ext'.
})
export default class Author extends SemanticModel {
  @string()
  givenName;

  @string()
  familyName;

  @hasMany({
    model: 'book',
    inverse: true,
    predicate: 'schema:author',
  })
  books;
}

```
In the ```hasMany``` relation, we are still required to explicitly provide the inverse predicate of the relationship.
When adding a new book to their collection, we would like for the user to be able to select the author corresponding to the book.
In order to be able to access the list of authors on the books route, add the following lines to the books model hook:

```javascript
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class BooksRoute extends Route {
  @service solidAuth;
  @service store;

  async beforeModel(){
    await this.solidAuth.ensureLogin();
  }

  async model() {
    await this.store.fetchGraphForType('book');
    await this.store.fetchGraphForType('author');
    return {
      books: this.store.all('book'),
      authors: this.store.all('author'),
    };
  }
}

```

Modify the books template so that it can correctly function with the new model hook:

```handlebars
{{page-title "Books"}}
<h2>Books</h2>
<ul>
{{#each @model.books as |book|}}
<li>{{book.headLine}} {{book.numberOfPages}} <button type="button" {{on "click" (fn this.deleteBook book)}}>Delete</button></li>
{{/each}}
</ul>
<BookForm @onSubmit={{this.createBook}} @authors={{@model.authors}}/>
```

We should also modify the book-form component so that users can select an author when creating a new book. In the book-form component, authors can be passed using the authors-property.

```handlebars
<form {{on "submit" this.onCreateBook}}>
    <label for="title">Title</label>
    <Input id="title" 
           @type="text"
           @value={{this.headLine}}/>
    <label for="numberOfPages">Page Count</label> 
    <Input id="numberOfPages"
            @type="text"
            @value={{this.numberOfPages}}/>
    <select {{on "change" this.setAuthor}} >
        <option value="">Select...</option>
        {{#each @authors as |author|}}
            <option value={{author.uri}}>{{author.givenName}}</option>
        {{/each}}
    </select>
    <button type="submit">Create Book</button>
</form>
```

```javascript
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class BookFormComponent extends Component {
  @tracked
  headLine;

  @tracked
  numberOfPages;

  @tracked
  authorURI;

  @action
  onCreateBook(event) {
    event.preventDefault();
    this.args.onSubmit(this.headLine, this.numberOfPages, this.authorURI);
    this.headLine = '';
    this.numberOfPages = '';
  }

  @action
  setAuthor(event) {
    event.preventDefault();
    this.authorURI = event.target.value;
  }
}

```
In the select element, we use the author URI's as unique values for the different entries. The book-form javascript class uses the ```onSubmit``` callback in order to send the user-inputted information back to the controller.
To finish up the application we finalize the implementation of the ```createBook``` action in the BooksController.

```javascript
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class BooksController extends Controller {
  @service router;
  @service store;

  @action
  async createBook(headLine, numberOfPages, authorURI) {
    let author = authorURI
      ? await this.store.peekInstance('author', authorURI.slice(1, -1))
      : undefined;

    this.store.create('book', {
      headLine: headLine,
      numberOfPages: numberOfPages,
      author: author,
    });

    await this.store.persist();

    this.router.refresh();
  }

  @action
  async deleteBook(book) {
    book.destroy();
    await this.store.persist();

    this.router.refresh();
  }
}

```

When visiting the books page, you should now have the option to select an author when creating a new book.